#!/usr/bin/env ruby
# frozen_string_literal: true

#-------------------------------------------------------------------------------
# cue2tracklist
# MIT License, (c) 2022 Liam Cooke
#-------------------------------------------------------------------------------
#
# Naive cue file parser. Reads a cue file from standard input, and prints
# a plain text tracklist. Made for a specific use case: extracting tracklists
# from Rekordbox DJ recordings.
#
# Example:
#
#   $ cue2tracklist < examples/example.cue
#   Silence Groove - Feel
#   Silence Groove - Offset
#   The Vagrant - This Is...
#   Dead Man's Chest - Westworld
#   Eusebeia - Vision
#   Paradox - Isotoxal
#
#-------------------------------------------------------------------------------

require 'set'

class CueFile
  attr_reader :tracks

  def self.parse(file)
    new.parse(file)
  end

  def parse(file)
    @tracks = []
    @track = {}
    @seen = Set.new

    file.readlines.each { |line| parse_line(line.rstrip) }
    next_track
    self
  end

  def to_s
    tracks.map do |track|
      artist = track.fetch(:artist, '?')
      title = track.fetch(:title, '?')
      "#{artist} - #{title}"
    end.join("\n")
  end

  def track_count
    tracks.size
  end

  private

  def parse_line(line)
    info = line.match(/^\s+(?<key>\w+) (?<value>.+)$/)
    case info && info[:key]
    when 'TRACK' then next_track
    when 'PERFORMER' then update_track(:artist, info[:value])
    when 'TITLE' then update_track(:title, info[:value])
    end
  end

  def next_track
    tracks << @track unless @track.empty? || @seen.include?(@track)
    @seen.add(@track)
    @track = {}
  end

  def update_track(key, value)
    @track[key] = value.match?(/^".*"$/) ? value[1...-1] : value
  end
end

cue_file = CueFile.parse($stdin)
if cue_file.track_count > 0
  puts cue_file
else
  warn 'No tracks detected'
  exit 1
end
